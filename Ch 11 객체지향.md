# Ch. 11 객체지향

# 생성자

내가 코드 안 치면 비어있는 디폴트 생성자 만들어줌

내가 생성자 만들면 디폴트 생성자 만들어지지 않음

객체 변수에 값을 무조건 설정해야만 객체가 생성될 수 있게 강제하는 방법으로 생성자를 쓸 수 있다. 

생성자는 클래스명과 메소드명이 같으며 리턴타입을 쓰지 않는다. 

생성자도 오버로딩이 가능하다. 

# 상속

단일 상속만 가능

`extends` 키워드를 사용

# 오버로딩

한 클래스에서 매개변수가 다른, 같은 이름의 메소드 여러 개를 정의할 수 있는 것을 말한다. 

매개변수의 개수나 타입이 다르면 서로 다른 메소드로 본다. 하지만, 리턴타입만 다른 경우는 모호하기 때문에 허용되지 않는다. 

같은 기능을 하는 메소드를 하나의 이름으로 지정해 가독성을 높이는 장점이 있다. 

```java
public class OverloadingTest {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        **System.out.println(calc.add(1, 2));
        System.out.println(calc.add(1, 2, 3));**
    }
}

class Calculator {
    public int add(int a, int b){
        return a + b;
    }
    public int add(int a, int b, int c){
        return a + b + c;
    }
}
```

# 오버라이딩

부모 클래스에서 상속받은 메소드의 내용을 자식 클래스의 상황에 맞게 변경하는 것으로, 메소드 이름, 매개변수, 리턴타입이 모두 같아야 오버라이딩된다. 오버라이딩 메소드는 오버리든 메소드 리턴타입의 서브타입을 리턴해도 된다. 

오버라이딩할 때는 `@Override` 애노테이션을 쓸 수 있다. 컴파일러가 정말 오버라이드를 하는지 확인하고 그렇지 않다면 에러를 던진다. 

오버라이딩 메소드는 오버리든 메소드의 접근제어자를 더 넓게 설정할 수는 있어도, 더 좁게 설정할 수는 없다. 

예를 들어 오버리든 메소드가 `default` 접근제어를 한다면, 오버라이딩 메소드는 더 넓은 `default`, `protected`, `public`으로 설정 가능하다. 하지만 `private`으로 설정할 수는 없다. 

오버라이딩 메소드는 오버리든 메소드가 throw하는 exception보다 작은 범위의 exception만 throw할 수 있다. 

```java
public class OverridingTest {
    public static void main(String args[]){
        Person person = new Person();
        Child child = new Child();
        Senior senior = new Senior();

        person.cry();
        child.cry();
        senior.cry();
    }
}

class Person {
    void cry() {
        System.out.println("흑흑");
    }
}

class Child extends Person {
    @Override
    protected void cry() {
        System.out.println("응애");
    }
}

class Senior extends Person {
    public void cry() {
        System.out.println("훌쩍훌쩍");
    }
}
```

## static 메소드 오버라이딩

static 메소드도 같은 메소드 이름, 매개변수, 리턴타입의 메소드를 서브클래스에 적어줄 수 있다. 단, 이 경우는 오버라이딩의 방식이 아닌 숨기는 방식으로 작동한다. 무슨 말인지 예시를 통해 설명한다. 

### 예시

```java
public class StaticHideTest {
    public static void main(String[] args){
        Cat myCat = new Cat();
        Animal myAnimal = myCat;
        myCat.testClassMethod(); // The static method in Cat
        myAnimal.testClassMethod(); // The static method in Animal
				
				myCat.testInstanceMethod(); // The instance method in Cat
        myAnimal.testInstanceMethod(); // The instance method in Cat
    }
}

class Animal {
    public static void testClassMethod() {
        System.out.println("The static method in Animal");
    }
    public void testInstanceMethod() {
        System.out.println("The instance method in Animal");
    }
}

class Cat extends Animal {
    public static void testClassMethod() {
        System.out.println("The static method in Cat");
    }
    public void testInstanceMethod() {
        System.out.println("The instance method in Cat");
    }
}
```

사실 같은 객체를 가리키는 myCat과 myAnimal에서 각각 static 메소드를 호출하면, 각자 다른 함수를 호출하는 것을 볼 수 있다. myCat은 Cat 클래스의 static 메소드를 호출하고, myAnimal은 Animal 클래스의 static 메소드를 호출한다. 

반면 myCat과 myAnimal에서 인스턴스 메소드를 호출하면, Cat 객체이므로 Cat 클래스의 인스턴스 메소드가 호출되는 것을 볼 수 있다. 

### 오버라이딩으로 static 여부가 바뀔 수는 없다

static 메소드를 인스턴스 메소드로 오버라이드할 수 없다. 

인스턴스 메소드를 static 메소드로 오버라이드할 수 없다. 

# 인터페이스

클래스와 유사한데, 요구하는 메소드를 반드시 구현해야 함. (클래스는 오버라이드하는 것이 선택)

인터페이스에는 보통 메소드 몸통을 정의하지 않음

```java
interface Predator {
    String getFood();
}
```

인터페이스를 구현하는 클래스들이 정의함. 정의하지 않으면 컴파일 에러

`class` 키워드 자리에 `interface` 키워드를 사용

`extends` 키워드 자리에 `implements` 키워드를 사용

한 클래스는 하나의 클래스만 extend할 수 있는 반면, 여러 개의 인터페이스를 implement할 수 있음

인터페이스는 클래스처럼 자료형처럼 사용할 수 있음

```java
class ZooKeeper {
    void feed(Tiger tiger) {
        System.out.println("feed apple");
    }

    void feed(Lion lion) {
        System.out.println("feed banana");
    }
}
```

```java
class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed apple");
    }
}
```

## 디폴트 메소드

디폴트 메소드로 메소드 몸통을 구현한 인터페이스 메소드를 만들 수도 있음. 클래스의 인스턴스 메소드와 매우 유사

```java
interface Predator {
    **default** void printFood() {
        System.out.printf("my food is %s\n", getFood());
    }
}
```

## 스태틱 메소드

클래스의 스태틱 메소드와 매우 유사

```java
interface Predator {
    int LEG_COUNT = 4;  // 인터페이스 상수

    static int speed() {
        return LEG_COUNT * 30;
    }
}
```

인터페이스 상수는 자동으로 `public static final`이 적용된다. 

```java
Predator.speed(); // 120
Predator.LEG_COUNT; // 4
```